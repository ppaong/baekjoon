# Lecture0

강의 내용에 필요한 기초지식을 습득합니다.

* pointer
* class
* OOP
* 




## What is Algorithm

알고리즘은 수학적 문제풀이의 한 종류입니다.

세상의 모든 수학문제 중에는 특정 방정식을 풀어서 어떤 문제의 해를 구할 수 있는 문제도 있지만, 그것만으로는 풀수없는 문제들이 많이 존재합니다.

예시로 어떤 수가 소수인지 판단해봅시다.

이러한 문제를 위해서 어떤 특정 작업(함수)를 *반복적으로* 적용하여 풀어내는 방법이 고안되었습니다. ex) 소인수 분해,최대공약수 찾기

알고리즘을 짜는것하고 알고리즘의 타당성을 증명하는것은 다른일.

귀납적인 사고방식과 




> plus, 알콰리즈미의 이름이 라틴어로 번역되며 알고리즘이란 단어의 기원이 되었습니다. 그리고 대수학을 뜻하는 algebra(알제브라)는 그가 집필한 책 al-jabr wa al-muqabala로 부터 기원되었습니다. 그는 대수학의 아버지로 불리며, 현대수학에 기초적인 분야에서 많은 기어를 한 업적이 있습니다.


### ex) 
실제로 stochestic differnetal equation의 논문들을 보면 pusedo code로 작성된 알고리즘부분을 찾아볼수있다.






## Mathamatical Induction

기본적인 증명 방법론중 하나인 수학적 귀납법입니다.

귀납적인 증명을 보이기 위해서 해야할 일은 딱 2가지 입니다.
1. 0번째 단계(초항)에서 공식이 성립함을 보인다.
2. n번째 단계가 성립한다 가정할때 n+1번째 단계에서 공식이 성립함을 보인다.


간단히 컴공버전으로 써보면,
1. 0번째 단계는 true다.
2. if n번째 단계가 true라면,then n+1번째 단계도 true다.

근데 이게 왜 되냐. 사실 재귀함수같은 방식으로 작동하는 논리입니다.   
$P_1\to P_2\to ...\to P_n\to P_{n+1} \to ...$

위의 2가지 사실관계만 보여도, 모든 자연수에서 명제가 성립함을 증명할 수 있는 쉽고 강력한 증명기법입니다.

__어떤 문제를 분할하고 재귀적 방식을 통해 모든 문제를 정복하는 형태의 증명에서 가장 중요하게 사용되는 개념이므로 꼭 알고있어야 합니다.__

> plus, 이후 배우게 될, Divide and Conquer와, dynamic programming에서 더 어렵고 복잡한 형태(2변수 이상에서 귀납법)의 증명을 자세하게 배우게 될 것입니다. 이 쳅터에서는 간단히 소개만 하는 정도 입니다.




### ex) n까지의 자연수 합

n까지의 자연수 합 $1+2+...+n=\frac{n(n+1)}{2}$ 이 항상 성립하는지 증명해볼수 있습니다.
1. 자연수는 1부터 시작하니, 1까지의 합은 $1=\frac{1(1+1)}{2}=1$이므로 초항에서 성립합니다.
2. n까지의 합 $1+2+...+n=\frac{n(n+1)}{2}$ 이 성립한다 가정할때, (n+1)까지의 합은 $1+2+...+n+(n+1)=\frac{(n+1)((n+1)+1)}{2}=\frac{(n+1)(n+2)}{2}=\frac{n(n+1)+2(n+1)}{2}=\frac{n(n+1)}{2}+(n+1)$이므로 성립합니다.
* 따라서 수학적 귀납법에 따라 본 명제는 참 입니다.

> plus, Peano Axiom에 기반하여 어떤 규칙을 만족하는 집합이 자연수 집합과 같음을 보이는 증명기법입니다. __~~(자세한것은 수학과 이중전공을 하고 전공수업중 해석학을 듣으. 읍읍..)~~__




### 주의할점

이름이 비슷하긴 하지만, "__수학적__ 귀납법"은 그냥 "귀납논증", "귀납법" 하고 다릅니다.    
귀납논증, 귀납법:
1. 1번째 단계가 true다.
2. 2반쩨 단계가 true다.
3. ...
4. n번째 단계가 true다.
5. 따라서 모든 n+1단계가 true다.

1~n단계까지 전부 true임을 보이고, n+1단계가 true라고 하는 논리인데, 이는 반례가 존재할 여지가 큽니다. (예시로 태어난 순간부터 오늘까지(1~n단계) 자신이 잘 살아있었다고 해서, 내일(n+1단계)도 살아있을거란 믿음이 항상 참은 아니다.)

$(P_1=true, P_2=true,..., P_n=true)\to  P_{n+1}=true$(1~n단계와 n+1단계 사이에는 추측만 존재할뿐, 논리적인 관계는 없다.)

이러한 논리는 증명에서 쓸수 없습니다.   
보통은 이공계에서 귀납법, 귀납적 증명이라 하면 무조건 "__수학적__ 귀납법"을 말합니다. 





## Definition of Function

이러한 논리아레에서 정수를 다루는 함수를 가정하고 증명해볼수있습니다.

예시로 


## Assumtion and proof

### ex)
예시로 merge sort를 증명할때 이 방식이 굉장히 유용합니다.
어떤 함수가 있는데 이 함수에 들어가면 sort할수있다고 가정합니다.(굉장히 무책임한 가정입니다. 어떻게 증명할지도 생각없이 일단 가정부터 합니다.)
이 함수는 수열을 반으로 쪼갭니다.


## Time Complexity

가상머신
입력크기 N에 따른 시간 계산

같은 기능을 수행하는 코드를 짜더라도, 시간복잡도는 다를수 있습니다. 이 경우 시간복잡도가 짧은 코드가 훨신 적은 계산으로 같은 문제를 해결할수 있다는 의미가 되므로, 효율적인 코드에서 시간복잡도 계산이 중요한것을 알 수 있습니다.

### 수행시간과 가상머신


## Big O Notation (Landau notation)

### 가상머신, 

### Big O


> plus, 수학/이론과학 계열에서는 Big O 표기법을 포함한 점근적 표기를 asymptotic notation(점근 표기법) 혹은 Landau notation(란다우 표기법)이라고 부른다. 여기 정리된 정의보다 더 엄밀하게 정의하여 사용한다. (사실 학부과정에서 여기까지는 필요없다.)



## STL